#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
DIAGNÃ“STICO Y REPARACIÃ“N DE PASSWORD - RODOLFO
===============================================

Este script diagnostica y repara problemas de autenticaciÃ³n.

Uso:
    python fix_rodolfo_password.py
"""

import sys
import os
import sqlite3
import hashlib
from pathlib import Path

# Agregar el directorio raÃ­z al path
sys.path.insert(0, str(Path(__file__).parent))

from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.backends import default_backend

def hash_password_100k(password: str, salt: str) -> str:
    """
    Hash password usando PBKDF2 con 100,000 iteraciones (mÃ©todo actual).
    """
    # Convertir salt de hex a bytes
    salt_bytes = bytes.fromhex(salt)
    
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=salt_bytes,
        iterations=100000,
        backend=default_backend()
    )
    
    key = kdf.derive(password.encode('utf-8'))
    return key.hex()

def hash_password_legacy(password: str, salt: str) -> str:
    """
    Hash password usando mÃ©todo legacy (si existÃ­a antes).
    """
    # MÃ©todo simple SHA256
    return hashlib.sha256(f"{password}{salt}".encode('utf-8')).hexdigest()

def get_user_data(username: str):
    """
    Obtiene los datos del usuario desde la base de datos.
    """
    db_path = Path(f"data/vault_{username.lower()}.db")
    
    if not db_path.exists():
        print(f"âŒ Base de datos no encontrada: {db_path}")
        return None
    
    try:
        conn = sqlite3.connect(str(db_path))
        cursor = conn.cursor()
        
        # Obtener datos del usuario
        cursor.execute("""
            SELECT username, password_hash, salt, vault_salt, role
            FROM users
            WHERE username = ?
        """, (username.upper(),))
        
        row = cursor.fetchone()
        conn.close()
        
        if row:
            return {
                'username': row[0],
                'password_hash': row[1],
                'salt': row[2],
                'vault_salt': row[3],
                'role': row[4]
            }
        return None
    except Exception as e:
        print(f"âŒ Error leyendo base de datos: {e}")
        return None

def update_password(username: str, new_password: str, salt: str):
    """
    Actualiza la contraseÃ±a en la base de datos.
    """
    db_path = Path(f"data/vault_{username.lower()}.db")
    
    # Calcular nuevo hash
    new_hash = hash_password_100k(new_password, salt)
    
    try:
        conn = sqlite3.connect(str(db_path))
        cursor = conn.cursor()
        
        cursor.execute("""
            UPDATE users
            SET password_hash = ?
            WHERE username = ?
        """, (new_hash, username.upper()))
        
        conn.commit()
        conn.close()
        
        return True
    except Exception as e:
        print(f"âŒ Error actualizando contraseÃ±a: {e}")
        return False

def main():
    print("="*70)
    print("ğŸ”§ DIAGNÃ“STICO Y REPARACIÃ“N DE PASSWORD - VULTRAX CORE")
    print("="*70)
    print()
    
    username = "RODOLFO"
    
    # 1. Obtener datos actuales
    print(f"ğŸ“Š Obteniendo datos de usuario: {username}")
    user_data = get_user_data(username)
    
    if not user_data:
        print(f"âŒ No se pudo obtener datos del usuario {username}")
        return 1
    
    print(f"âœ… Datos encontrados:")
    print(f"   Username: {user_data['username']}")
    print(f"   Salt: {user_data['salt']}")
    print(f"   Hash actual: {user_data['password_hash'][:16]}...")
    print(f"   Role: {user_data['role']}")
    print()
    
    # 2. Pedir contraseÃ±a actual para verificar
    print("ğŸ” VerificaciÃ³n de contraseÃ±a")
    print("-" * 70)
    current_password = input("Ingrese la contraseÃ±a que estÃ¡ intentando usar: ")
    
    # 3. Probar con 100k iteraciones (mÃ©todo actual)
    print()
    print("ğŸ§ª Probando con PBKDF2 (100,000 iteraciones)...")
    calc_hash_100k = hash_password_100k(current_password, user_data['salt'])
    
    print(f"   Hash calculado: {calc_hash_100k[:16]}...")
    print(f"   Hash almacenado: {user_data['password_hash'][:16]}...")
    
    if calc_hash_100k == user_data['password_hash']:
        print("âœ… Â¡La contraseÃ±a es CORRECTA con el mÃ©todo actual!")
        print("   El problema no estÃ¡ en la contraseÃ±a.")
        print()
        print("ğŸ” Posibles causas:")
        print("   1. Error en la lÃ³gica de verify_password en user_manager.py")
        print("   2. Problema de encoding UTF-8")
        print("   3. Salt corrupto en memoria vs base de datos")
        print()
        print("ğŸ’¡ SOLUCIÃ“N:")
        print("   Revise el cÃ³digo en src/infrastructure/user_manager.py")
        print("   LÃ­neas ~550-600 (funciÃ³n verify_password)")
        return 0
    
    print("âŒ La contraseÃ±a NO coincide con el mÃ©todo actual")
    print()
    
    # 4. Probar con mÃ©todo legacy
    print("ğŸ§ª Probando con mÃ©todo legacy (SHA256 simple)...")
    calc_hash_legacy = hash_password_legacy(current_password, user_data['salt'])
    
    if calc_hash_legacy == user_data['password_hash']:
        print("âœ… Â¡La contraseÃ±a coincide con el mÃ©todo LEGACY!")
        print()
        print("ğŸ”§ PROBLEMA IDENTIFICADO:")
        print("   El hash en la BD usa un mÃ©todo antiguo (SHA256 simple)")
        print("   pero el cÃ³digo actual usa PBKDF2 con 100k iteraciones.")
        print()
        
        # Ofrecer migraciÃ³n
        print("ğŸ’¾ Â¿Desea MIGRAR la contraseÃ±a al nuevo formato?")
        print("   Esto actualizarÃ¡ el hash en la base de datos.")
        response = input("   (S/N): ").strip().upper()
        
        if response == 'S':
            print()
            print("ğŸ”„ Migrando contraseÃ±a...")
            if update_password(username, current_password, user_data['salt']):
                print("âœ… Â¡ContraseÃ±a migrada exitosamente!")
                print()
                print("ğŸ‰ Ahora puede iniciar sesiÃ³n normalmente.")
                return 0
            else:
                print("âŒ Error durante la migraciÃ³n")
                return 1
        else:
            print("âŒ MigraciÃ³n cancelada")
            return 1
    
    print("âŒ La contraseÃ±a NO coincide con ningÃºn mÃ©todo conocido")
    print()
    
    # 5. Ofrecer reset de contraseÃ±a
    print("="*70)
    print("ğŸ†˜ OPCIONES DE RECUPERACIÃ“N")
    print("="*70)
    print()
    print("1. RESET DE CONTRASEÃ‘A - Establecer nueva contraseÃ±a")
    print("2. SALIR - Cancelar operaciÃ³n")
    print()
    
    choice = input("Seleccione opciÃ³n (1/2): ").strip()
    
    if choice == "1":
        print()
        print("ğŸ” RESET DE CONTRASEÃ‘A")
        print("-" * 70)
        new_password = input("Ingrese NUEVA contraseÃ±a: ")
        confirm = input("Confirme NUEVA contraseÃ±a: ")
        
        if new_password != confirm:
            print("âŒ Las contraseÃ±as no coinciden")
            return 1
        
        if len(new_password) < 8:
            print("âŒ La contraseÃ±a debe tener al menos 8 caracteres")
            return 1
        
        print()
        print("âš ï¸  ADVERTENCIA: Esta operaciÃ³n cambiarÃ¡ su contraseÃ±a maestra.")
        print("   AsegÃºrese de recordar la nueva contraseÃ±a.")
        final_confirm = input("   Â¿Continuar? (SI/NO): ").strip().upper()
        
        if final_confirm == "SI":
            print()
            print("ğŸ”„ Actualizando contraseÃ±a...")
            if update_password(username, new_password, user_data['salt']):
                print("âœ… Â¡ContraseÃ±a actualizada exitosamente!")
                print()
                print("ğŸ‰ Puede iniciar sesiÃ³n con su nueva contraseÃ±a.")
                print()
                print("ğŸ“ NUEVA CONTRASEÃ‘A:")
                print(f"   {new_password}")
                print()
                print("   âš ï¸  Guarde esta contraseÃ±a en un lugar seguro.")
                return 0
            else:
                print("âŒ Error actualizando contraseÃ±a")
                return 1
        else:
            print("âŒ OperaciÃ³n cancelada")
            return 1
    
    print("âŒ OperaciÃ³n cancelada")
    return 1

if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print("\n\nâŒ OperaciÃ³n cancelada por el usuario")
        sys.exit(1)
    except Exception as e:
        print(f"\n\nâŒ Error inesperado: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)